/**
 * // 对各种类型的数据进行合并后处理
 // 每隔一段时间提交一次
 // 或每隔一段时间提交一次

 // 某种消息,第一次进来会立马执行
 // 主要应对canal消息,进行合并后处理

 // 设计目标在并发写入的时候, 可以定时cas的合并消息,然后提交;
 // 消息不会源源不断的来的, 如果尝试几次失败了的话, 就强制加锁提交消息. 类似于ConcurrentHashMap
 // 高性能的系统,很多结构都要自己定制的.
 // 供应商那边会有价格消息定时导入 以及 汇率商品定时批量更新的问题

 // 上次我的设计是想利用读写锁?
 // 还有想利用cas的工具类,进行cas的修改,避免加锁.

 // todo getAndUpdate
 // segment数和线程数关系的影响也可以测试下. 这应该是个相对固定的值,因为lts的线程数是可控的.

 // 继承读写锁,是想对对象整体加锁

 // 这个send动作,其实就是插入的意思,就是都是增量的消息.

 // 更多的利用cas而不是锁,两种方案一起比较下看看呢.
 // 这个可以写个Blog. 比较下不同方案的处理量.
 // 还有关于价格多级缓存的,后面也要做一下,不一定要上线,但是要实现出来.
 // 没有消息的,会有一个线程主动扫描一次.判断消息的上次发送时间,先CAS更新时间,再发送一次.
 // 在发送消息的时候,先对AtomicReference.

 // 这里主要是用来做共享锁和独占锁来使用的
 // 往里面添加数据,是用的cas,因为只会新增,所以cas没有aba的风险
 // 删除对象也可以使用cas吧? 不行? 需要删除对象
 // 是否也可以将开始结束时间更新为null呢? 这样下次就没有数据要更新了, 就是更新为null, 也是用cas.
 // 但是这样有个不好的情况,就是会有残留的对象, 怎么清除呢?
 // 还是最好在提交的时候, 对每个id对象进行加锁, 然后进行清理.
 // 这个锁, 当然最好最好是加在每个对象上了, 这样就没有全局的锁
 */
package com.github.my_study.concurrent;